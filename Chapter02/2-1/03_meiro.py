
#キューを使うためインポート
from queue import Queue

#入力
N = int(input())
M = int(input())
#迷路の情報
maze =[
    ['#','S','#','#','#','#','#','#','.','#'],
    ['.','.','.','.','.','.','#','.','.','#'],
    ['.','#','.','#','#','.','#','#','.','#'],
    ['.','#','.','.','.','.','.','.','.','.'],
    ['#','#','.','#','#','.','#','#','#','#'],
    ['.','.','.','.','#','.','.','.','.','#'],
    ['.','#','#','#','#','#','#','#','.','#'],
    ['.','.','.','.','#','.','.','.','.','.'],
    ['.','#','#','#','#','.','#','#','#','.'],
    ['.','.','.','.','#','.','.','.','G','#']
    ]
#スタート地点
si = 0
sj = 1
#ゴール地点
gi = 9
gj = 8

INF = 100000000
#各点までの最短距離の配列(すべての点をINFで初期化)
d = [[INF] * N for i in [INF] * M]
#移動四方向のベクトル(下、右,上、左)
di = [1,0,-1,0]
dj = [0,1,0,-1]

#スタートからゴールまでの最短距離を求める
#たどり着けないとINF
def bfs():
    q = Queue()
    #スタート地点をキューに入れ、その点の距離を0にする
    q.put([si,sj])
    d[si][sj] = 0
    d_t = d
    #キューが空になるまでループ
    while(not(q.empty())):
        #キューの先頭を取り出す
        qi,qj = q.get()
        #取り出した値がゴールなら探索をやめる
        if (qi == gi) and (qj == gj):
            break
        #移動4方向をループ
        for i in range(4):
            #移動したあとの点を(nx,ny)とする。
            ni = qi + di[i]
            nj = qj + dj[i]

            #移動が可能かの判定とすでに訪れたことがあるかの判定
            if (0 <= ni and ni < N) and (0 <= nj and nj < M) and (maze[ni][nj] != '#') and (d[ni][nj] == INF):
                #移動できるならキューに入れその点の距離をpからの距離+1で確定する
                q.put([ni,nj])
                d[ni][nj] = d[qi][qj] + 1
    
    return d[gi][gj]

count = bfs()
print(count)